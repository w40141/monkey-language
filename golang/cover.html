
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ast: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/w40141/monkey-language/golang/ast/block.go (80.0%)</option>
				
				<option value="file1">github.com/w40141/monkey-language/golang/ast/boolean.go (0.0%)</option>
				
				<option value="file2">github.com/w40141/monkey-language/golang/ast/call.go (0.0%)</option>
				
				<option value="file3">github.com/w40141/monkey-language/golang/ast/expression.go (0.0%)</option>
				
				<option value="file4">github.com/w40141/monkey-language/golang/ast/function.go (0.0%)</option>
				
				<option value="file5">github.com/w40141/monkey-language/golang/ast/identifire.go (50.0%)</option>
				
				<option value="file6">github.com/w40141/monkey-language/golang/ast/if.go (0.0%)</option>
				
				<option value="file7">github.com/w40141/monkey-language/golang/ast/infix.go (0.0%)</option>
				
				<option value="file8">github.com/w40141/monkey-language/golang/ast/integer.go (0.0%)</option>
				
				<option value="file9">github.com/w40141/monkey-language/golang/ast/let.go (100.0%)</option>
				
				<option value="file10">github.com/w40141/monkey-language/golang/ast/prefix.go (0.0%)</option>
				
				<option value="file11">github.com/w40141/monkey-language/golang/ast/program.go (100.0%)</option>
				
				<option value="file12">github.com/w40141/monkey-language/golang/ast/return.go (0.0%)</option>
				
				<option value="file13">github.com/w40141/monkey-language/golang/lexer/functions.go (100.0%)</option>
				
				<option value="file14">github.com/w40141/monkey-language/golang/lexer/lexer.go (98.3%)</option>
				
				<option value="file15">github.com/w40141/monkey-language/golang/main.go (0.0%)</option>
				
				<option value="file16">github.com/w40141/monkey-language/golang/parser/parser.go (85.4%)</option>
				
				<option value="file17">github.com/w40141/monkey-language/golang/parser/trace.go (0.0%)</option>
				
				<option value="file18">github.com/w40141/monkey-language/golang/repl/repl.go (0.0%)</option>
				
				<option value="file19">github.com/w40141/monkey-language/golang/token/token.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import (
        "bytes"

        "github.com/w40141/monkey-language/golang/token"
)

var _ Expression = (*BlockStatement)(nil)

// BlockStatement represents a block statement in the AST.
type BlockStatement struct {
        Token     token.Token
        Statements []Statement
}

// String implements Expression.
func (b *BlockStatement) String() string <span class="cov8" title="1">{
        var out bytes.Buffer

        for _, s := range b.Statements </span><span class="cov0" title="0">{
                out.WriteString(s.String())
        }</span>

        <span class="cov8" title="1">return out.String()</span>
}

// TokenLiteral implements Expression.
func (b *BlockStatement) TokenLiteral() string <span class="cov8" title="1">{
        return b.Token.Literal
}</span>

// expressionNode implements Expression.
func (b *BlockStatement) expressionNode() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import "github.com/w40141/monkey-language/golang/token"

var _ Expression = (*Boolean)(nil)

// Boolean represents a boolean value in the AST.
type Boolean struct {
        Token token.Token
        Value bool
}

// String implements Expression.
func (b *Boolean) String() string <span class="cov0" title="0">{
        return b.Token.Literal
}</span>

// TokenLiteral implements Expression.
func (b *Boolean) TokenLiteral() string <span class="cov0" title="0">{
        return b.Token.Literal
}</span>

// expressionNode implements Expression.
func (b *Boolean) expressionNode() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import (
        "bytes"
        "strings"

        "github.com/w40141/monkey-language/golang/token"
)

var _ Expression = (*CallExpression)(nil)

// CallExpression represents a call expression in the AST.
type CallExpression struct {
        Token     token.Token
        Function  Expression
        Arguments []Expression
}

// String implements Expression.
func (c *CallExpression) String() string <span class="cov0" title="0">{
        var out bytes.Buffer

        args := []string{}
        for _, arg := range c.Arguments </span><span class="cov0" title="0">{
                args = append(args, arg.String())
        }</span>

        <span class="cov0" title="0">out.WriteString(c.Function.String())
        out.WriteString("(")
        out.WriteString(strings.Join(args, ", "))
        out.WriteString(")")

        return out.String()</span>
}

// TokenLiteral implements Expression.
func (c *CallExpression) TokenLiteral() string <span class="cov0" title="0">{
        return c.Token.Literal
}</span>

// expressionNode implements Expression.
func (c *CallExpression) expressionNode() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import "github.com/w40141/monkey-language/golang/token"

var _ Statement = (*ExpressionStatement)(nil)

// ExpressionStatement represents an expression statement in the AST.
type ExpressionStatement struct {
        Token      token.Token
        Expression Expression
}

// String implements Statement.
func (es *ExpressionStatement) String() string <span class="cov0" title="0">{
        if es.Expression != nil </span><span class="cov0" title="0">{
                return es.Expression.String()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (es *ExpressionStatement) statementNode() {<span class="cov0" title="0">}</span>

// TokenLiteral returns the token literal of the expression statement.
func (es *ExpressionStatement) TokenLiteral() string <span class="cov0" title="0">{
        return es.Token.Literal
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import (
        "bytes"
        "strings"

        "github.com/w40141/monkey-language/golang/token"
)

var _ Expression = (*FunctionLiteral)(nil)

// FunctionLiteral represents a function literal in the AST.
type FunctionLiteral struct {
        Token      token.Token
        Parameters []*Identifier
        Body       *BlockStatement
}

// String implements Expression.
func (fl *FunctionLiteral) String() string <span class="cov0" title="0">{
        var out bytes.Buffer

        params := []string{}
        for _, p := range fl.Parameters </span><span class="cov0" title="0">{
                params = append(params, p.String())
        }</span>

        <span class="cov0" title="0">out.WriteString(fl.TokenLiteral())
        out.WriteString("(")
        out.WriteString(strings.Join(params, ", "))
        out.WriteString(") ")
        out.WriteString(fl.Body.String())

        return out.String()</span>
}

// TokenLiteral implements Expression.
func (fl *FunctionLiteral) TokenLiteral() string <span class="cov0" title="0">{
        return fl.Token.Literal
}</span>

// expressionNode implements Expression.
func (f *FunctionLiteral) expressionNode() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import (
        "github.com/w40141/monkey-language/golang/token"
)

var _ Expression = (*Identifier)(nil)

// Identifier represents an identifier in the AST.
type Identifier struct {
        // Token is the token.IDENT token.
        Token token.Token
        Value string
}

// String implements Expression.
func (i *Identifier) String() string <span class="cov8" title="1">{
        return i.Value
}</span>

func (i *Identifier) expressionNode() {<span class="cov0" title="0">}</span>

// TokenLiteral returns the token literal of the identifier.
func (i *Identifier) TokenLiteral() string <span class="cov0" title="0">{
        return i.Token.Literal
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import (
        "bytes"

        "github.com/w40141/monkey-language/golang/token"
)

var _ Expression = (*IfExpression)(nil)

// IfExpression represents an if expression in the AST.
type IfExpression struct {
        Token       token.Token
        Condition   Expression
        Consequence *BlockStatement
        ALternative *BlockStatement
}

// String implements Expression.
func (ie *IfExpression) String() string <span class="cov0" title="0">{
        var out bytes.Buffer

        out.WriteString("if")
        out.WriteString(ie.Condition.String())
        out.WriteString(" ")
        out.WriteString(ie.Consequence.String())

        if ie.ALternative != nil </span><span class="cov0" title="0">{
                out.WriteString("else ")
                out.WriteString(ie.ALternative.String())
        }</span>

        <span class="cov0" title="0">return out.String()</span>
}

// TokenLiteral implements Expression.
func (ie *IfExpression) TokenLiteral() string <span class="cov0" title="0">{
        return ie.Token.Literal
}</span>

// expressionNode implements Expression.
func (ie *IfExpression) expressionNode() {<span class="cov0" title="0">}</span>

</pre>
		
		<pre class="file" id="file7" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import (
        "bytes"

        "github.com/w40141/monkey-language/golang/token"
)

var _ Expression = (*InfixExpression)(nil)

// InfixExpression represents an infix expression in the AST.
type InfixExpression struct {
        Token    token.Token
        Operator string
        Left     Expression
        Right    Expression
}

// String implements Expression.
func (p *InfixExpression) String() string <span class="cov0" title="0">{
        var out bytes.Buffer
        out.WriteString("(")
        out.WriteString(p.Left.String())
        out.WriteString(" " + p.Operator + " ")
        out.WriteString(p.Right.String())
        out.WriteString(")")
        return out.String()
}</span>

// TokenLiteral implements Expression.
func (p *InfixExpression) TokenLiteral() string <span class="cov0" title="0">{
        return p.Token.Literal
}</span>

// expressionNode implements Expression.
func (p *InfixExpression) expressionNode() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import "github.com/w40141/monkey-language/golang/token"

var _ Expression = (*IntegerLiteral)(nil)

// IntegerLiteral represents an integer literal in the AST.
type IntegerLiteral struct {
        Token token.Token
        Value int64
}

// expressionNode implements Expression.
func (i *IntegerLiteral) expressionNode() {<span class="cov0" title="0">}</span>

// String implements Node.
func (i *IntegerLiteral) String() string <span class="cov0" title="0">{
        return i.Token.Literal
}</span>

// TokenLiteral implements Node.
func (i *IntegerLiteral) TokenLiteral() string <span class="cov0" title="0">{
        return i.Token.Literal
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import (
        "bytes"

        "github.com/w40141/monkey-language/golang/token"
)

var _ Statement = (*LetStatement)(nil)

// LetStatement represents a let statement in the AST.
type LetStatement struct {
        // Token is the token.LET token.
        Token token.Token
        Name  *Identifier
        Value Expression
}

// String implements Statement.
func (ls *LetStatement) String() string <span class="cov8" title="1">{
        var out bytes.Buffer

        out.WriteString(ls.TokenLiteral() + " ")
        out.WriteString(ls.Name.String())
        out.WriteString(" = ")

        if ls.Value != nil </span><span class="cov8" title="1">{
                out.WriteString(ls.Value.String())
        }</span>

        <span class="cov8" title="1">out.WriteString(";")
        return out.String()</span>
}

func (ls *LetStatement) statementNode() {<span class="cov0" title="0">}</span>

// TokenLiteral returns the token literal of the let statement.
func (ls *LetStatement) TokenLiteral() string <span class="cov8" title="1">{
        return ls.Token.Literal
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import (
        "bytes"

        "github.com/w40141/monkey-language/golang/token"
)

var _ Expression = (*PrefixExpression)(nil)

// PrefixExpression represents a prefix expression in the AST.
type PrefixExpression struct {
        Token    token.Token
        Operator string
        Right    Expression
}

// String implements Expression.
func (p *PrefixExpression) String() string <span class="cov0" title="0">{
        var out bytes.Buffer
        out.WriteString("(")
        out.WriteString(p.Operator)
        out.WriteString(p.Right.String())
        out.WriteString(")")
        return out.String()
}</span>

// TokenLiteral implements Expression.
func (p *PrefixExpression) TokenLiteral() string <span class="cov0" title="0">{
        return p.Token.Literal
}</span>

// expressionNode implements Expression.
func (p *PrefixExpression) expressionNode() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import "bytes"

var _ Node = (*Program)(nil)

// Program represents a Monkey program.
type Program struct {
        Statements []Statement
}

// String implements Node.
func (p *Program) String() string <span class="cov8" title="1">{
        var out bytes.Buffer

        for _, s := range p.Statements </span><span class="cov8" title="1">{
                out.WriteString(s.String())
        }</span>
        <span class="cov8" title="1">return out.String()</span>
}

// TokenLiteral returns the token literal of the first statement in the program.
func (p *Program) TokenLiteral() string <span class="cov8" title="1">{
        if len(p.Statements) &gt; 0 </span><span class="cov8" title="1">{
                return p.Statements[0].TokenLiteral()
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package ast defines the abstract syntax tree for the Monkey programming language.
package ast

import (
        "bytes"

        "github.com/w40141/monkey-language/golang/token"
)

var _ Statement = (*ReturnStatement)(nil)

// ReturnStatement represents a return statement in the AST.
type ReturnStatement struct {
        // Token is the token.RETURN token.
        Token       token.Token
        ReturnValue Expression
}

// String implements Statement.
func (rs *ReturnStatement) String() string <span class="cov0" title="0">{
        var out bytes.Buffer

        out.WriteString(rs.TokenLiteral() + " ")

        if rs.ReturnValue != nil </span><span class="cov0" title="0">{
                out.WriteString(rs.ReturnValue.String())
        }</span>

        <span class="cov0" title="0">out.WriteString(";")
        return out.String()</span>
}

func (rs *ReturnStatement) statementNode() {<span class="cov0" title="0">}</span>

// TokenLiteral returns the token literal of the return statement.
func (rs *ReturnStatement) TokenLiteral() string <span class="cov0" title="0">{
        return rs.Token.Literal
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package lexer implements a lexer for the Monkey programming language.
package lexer

// New returns a new instance of Lexer.
func New(input string) *Lexer <span class="cov8" title="1">{
        l := Lexer{input: input}
        l.readChar()
        return &amp;l
}</span>

func isLetter(ch byte) bool <span class="cov8" title="1">{
        return ('a' &lt;= ch &amp;&amp; ch &lt;= 'z') || ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z') || ch == '_'
}</span>

func isDigit(ch byte) bool <span class="cov8" title="1">{
        return '0' &lt;= ch &amp;&amp; ch &lt;= '9'
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package lexer implements a lexer for the Monkey programming language.
package lexer

import (
        "github.com/w40141/monkey-language/golang/token"
)

// Lexer represents a lexer.
type Lexer struct {
        input string
        // current position in input (points to current char)
        position int
        // current reading position in input (after current char)
        readPosition int
        // current char under examination
        nowChar byte
}

func (l *Lexer) readChar() <span class="cov8" title="1">{
        if l.readPosition &gt;= len(l.input) </span><span class="cov8" title="1">{
                // 0 means EOF
                l.nowChar = 0
        }</span> else<span class="cov8" title="1"> {
                l.nowChar = l.input[l.readPosition]
        }</span>
        <span class="cov8" title="1">l.position = l.readPosition
        l.readPosition++</span>
}

// NextToken returns the next token.
func (l *Lexer) NextToken() token.Token <span class="cov8" title="1">{
        var tok token.Token
        l.skipWhitespace()
        switch l.nowChar </span>{
        case '=':<span class="cov8" title="1">
                if l.peekChar() == '=' </span><span class="cov8" title="1">{
                        ch := l.nowChar
                        l.readChar()
                        tok = token.Token{
                                Type:    token.EQ,
                                Literal: string(ch) + string(l.nowChar),
                        }
                }</span> else<span class="cov8" title="1"> {
                        tok = token.New(token.ASSIGN, l.nowChar)
                }</span>
        case '+':<span class="cov8" title="1">
                tok = token.New(token.PLUS, l.nowChar)</span>
        case '-':<span class="cov8" title="1">
                tok = token.New(token.MINUS, l.nowChar)</span>
        case '*':<span class="cov8" title="1">
                tok = token.New(token.TIMES, l.nowChar)</span>
        case '/':<span class="cov8" title="1">
                tok = token.New(token.DIVIDE, l.nowChar)</span>
        case '!':<span class="cov8" title="1">
                if l.peekChar() == '=' </span><span class="cov8" title="1">{
                        ch := l.nowChar
                        l.readChar()
                        tok = token.Token{
                                Type:    token.NQ,
                                Literal: string(ch) + string(l.nowChar),
                        }
                }</span> else<span class="cov8" title="1"> {
                        tok = token.New(token.BANG, l.nowChar)
                }</span>
        case ',':<span class="cov8" title="1">
                tok = token.New(token.COMMA, l.nowChar)</span>
        case ';':<span class="cov8" title="1">
                tok = token.New(token.SEMICOLON, l.nowChar)</span>
        case '(':<span class="cov8" title="1">
                tok = token.New(token.LPARAN, l.nowChar)</span>
        case ')':<span class="cov8" title="1">
                tok = token.New(token.RPARAN, l.nowChar)</span>
        case '{':<span class="cov8" title="1">
                tok = token.New(token.LBRACE, l.nowChar)</span>
        case '}':<span class="cov8" title="1">
                tok = token.New(token.RBRACE, l.nowChar)</span>
        case '&lt;':<span class="cov8" title="1">
                tok = token.New(token.LT, l.nowChar)</span>
        case '&gt;':<span class="cov8" title="1">
                tok = token.New(token.GT, l.nowChar)</span>
        case 0:<span class="cov8" title="1">
                tok.Literal = ""
                tok.Type = token.EOF</span>
        default:<span class="cov8" title="1">
                if isLetter(l.nowChar) </span><span class="cov8" title="1">{
                        tok.Literal = l.readIdentifier()
                        tok.Type = token.LookupIdent(tok.Literal)
                        return tok
                }</span> else<span class="cov8" title="1"> if isDigit(l.nowChar) </span><span class="cov8" title="1">{
                        tok.Literal = l.readNumber()
                        tok.Type = token.INT
                        return tok
                }</span> else<span class="cov8" title="1"> {
                        tok = token.New(token.ILLEGAL, l.nowChar)
                }</span>
        }
        <span class="cov8" title="1">l.readChar()
        return tok</span>
}

func (l *Lexer) readIdentifier() string <span class="cov8" title="1">{
        position := l.position
        nl := l
        for isLetter(nl.nowChar) </span><span class="cov8" title="1">{
                l.readChar()
        }</span>
        <span class="cov8" title="1">return l.input[position:nl.position]</span>
}

func (l *Lexer) readNumber() string <span class="cov8" title="1">{
        position := l.position
        nl := l
        for isDigit(nl.nowChar) </span><span class="cov8" title="1">{
                l.readChar()
        }</span>
        <span class="cov8" title="1">return l.input[position:nl.position]</span>
}

func (l *Lexer) skipWhitespace() <span class="cov8" title="1">{
        for l.nowChar == ' ' || l.nowChar == '\t' || l.nowChar == '\n' || l.nowChar == '\r' </span><span class="cov8" title="1">{
                l.readChar()
        }</span>
}

func (l *Lexer) peekChar() byte <span class="cov8" title="1">{
        if l.readPosition &gt;= len(l.input) </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return l.input[l.readPosition]</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package main is the entry point of the Monkey programming language.
package main

import (
        "fmt"
        "os"
        "os/user"

        "github.com/w40141/monkey-language/golang/repl"
)

func main() <span class="cov0" title="0">{
        user, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Hello %s! This is the Monkey programming language!\n", user.Username)
        fmt.Println("Feel free to type in commands")
        repl.Start(os.Stdin, os.Stdout)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package parser implements a parser for the Monkey programming language.
package parser

import (
        "fmt"
        "strconv"

        "github.com/w40141/monkey-language/golang/ast"
        "github.com/w40141/monkey-language/golang/lexer"
        "github.com/w40141/monkey-language/golang/token"
)

type (
        prefixParseFn func() ast.Expression
        infixParseFn  func(ast.Expression) ast.Expression
)

const (
        _ int = iota
        // LOWEST is the lowest precedence.
        LOWEST
        // EQUALS is the precedence for the == operator.
        EQUALS
        // LESSGREATER is the precedence for the &lt; or &gt; operators.
        LESSGREATER
        // SUM is the precedence for the + operator.
        SUM
        // PRODUCT is the precedence for the * operator.
        PRODUCT
        // PREFIX is the precedence for the -X or !X operators.
        PREFIX
        // CALL is the precedence for the myFunction(X) operator.
        CALL
)

var precedences = map[token.Type]int{
        token.EQ:     EQUALS,
        token.NQ:     EQUALS,
        token.LT:     LESSGREATER,
        token.GT:     LESSGREATER,
        token.PLUS:   SUM,
        token.MINUS:  SUM,
        token.DIVIDE: PRODUCT,
        token.TIMES:  PRODUCT,
        token.LPARAN: CALL,
}

func (p *Parser) peekPrecedence() int <span class="cov8" title="1">{
        if p, ok := precedences[p.peekToken.Type]; ok </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">return LOWEST</span>
}

func (p *Parser) curPrecedence() int <span class="cov8" title="1">{
        if p, ok := precedences[p.curToken.Type]; ok </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov0" title="0">return LOWEST</span>
}

// Parser is the Monkey parser.
type Parser struct {
        l      *lexer.Lexer
        errors []string

        curToken  token.Token
        peekToken token.Token

        prefixParseFns map[token.Type]prefixParseFn
        infixParseFns  map[token.Type]infixParseFn
}

// Errors returns the parser errors.
func (p *Parser) Errors() []string <span class="cov8" title="1">{
        return p.errors
}</span>

func (p *Parser) peekError(t token.Type) <span class="cov0" title="0">{
        msg := fmt.Sprintf("expected next token to be %s, got %s instead", t, p.peekToken.Type)
        p.errors = append(p.errors, msg)
}</span>

// New creates a new Parser.
func New(l *lexer.Lexer) *Parser <span class="cov8" title="1">{
        p := &amp;Parser{l: l, errors: []string{}}

        p.prefixParseFns = make(map[token.Type]prefixParseFn)
        p.registerPrefix(token.IDENT, p.parseIdentifier)
        p.registerPrefix(token.INT, p.parseIntegerLiteral)
        p.registerPrefix(token.BANG, p.parsePrefixExpression)
        p.registerPrefix(token.MINUS, p.parsePrefixExpression)
        p.registerPrefix(token.TRUE, p.parseBoolean)
        p.registerPrefix(token.FALSE, p.parseBoolean)
        p.registerPrefix(token.LPARAN, p.parseGroupedExpression)
        p.registerPrefix(token.IF, p.parseIfExpression)
        p.registerPrefix(token.FUNCTION, p.parseFunctionLiteral)

        p.infixParseFns = make(map[token.Type]infixParseFn)
        p.registerInfix(token.PLUS, p.parseInfixExpression)
        p.registerInfix(token.MINUS, p.parseInfixExpression)
        p.registerInfix(token.TIMES, p.parseInfixExpression)
        p.registerInfix(token.DIVIDE, p.parseInfixExpression)
        p.registerInfix(token.EQ, p.parseInfixExpression)
        p.registerInfix(token.NQ, p.parseInfixExpression)
        p.registerInfix(token.LT, p.parseInfixExpression)
        p.registerInfix(token.GT, p.parseInfixExpression)
        p.registerInfix(token.LPARAN, p.parseCallExpression)

        // Read two tokens, so curToken and peekToken are both set.
        p.nextToken()
        p.nextToken()
        return p
}</span>

func (p *Parser) parseIdentifier() ast.Expression <span class="cov8" title="1">{
        return &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
}</span>

func (p *Parser) parseIntegerLiteral() ast.Expression <span class="cov8" title="1">{
        lit := &amp;ast.IntegerLiteral{Token: p.curToken}

        value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
                p.errors = append(p.errors, msg)
                return nil
        }</span>

        <span class="cov8" title="1">lit.Value = value
        return lit</span>
}

func (p *Parser) parsePrefixExpression() ast.Expression <span class="cov8" title="1">{
        expression := &amp;ast.PrefixExpression{
                Token:    p.curToken,
                Operator: p.curToken.Literal,
        }

        p.nextToken()
        expression.Right = p.parseExpression(PREFIX)
        return expression
}</span>

func (p *Parser) parseBoolean() ast.Expression <span class="cov8" title="1">{
        return &amp;ast.Boolean{Token: p.curToken, Value: p.curTokenIs(token.TRUE)}
}</span>

func (p *Parser) parseGroupedExpression() ast.Expression <span class="cov8" title="1">{
        p.nextToken()
        exp := p.parseExpression(LOWEST)
        if !p.expectPeek(token.RPARAN) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return exp</span>
}

func (p *Parser) parseIfExpression() ast.Expression <span class="cov8" title="1">{
        exp := &amp;ast.IfExpression{Token: p.curToken}
        if !p.expectPeek(token.LPARAN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">p.nextToken()
        exp.Condition = p.parseExpression(LOWEST)

        if !p.expectPeek(token.RPARAN) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if !p.expectPeek(token.LBRACE) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">exp.Consequence = p.parseBlockStatement()

        if p.peekTokenIs(token.ELSE) </span><span class="cov8" title="1">{
                p.nextToken()
                if !p.expectPeek(token.LBRACE) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">exp.ALternative = p.parseBlockStatement()</span>
        }
        <span class="cov8" title="1">return exp</span>
}

func (p *Parser) parseBlockStatement() *ast.BlockStatement <span class="cov8" title="1">{
        block := &amp;ast.BlockStatement{Token: p.curToken}
        block.Statements = []ast.Statement{}
        p.nextToken()

        for !p.curTokenIs(token.RBRACE) &amp;&amp; !p.curTokenIs(token.EOF) </span><span class="cov8" title="1">{
                if stmt := p.parseStatement(); stmt != nil </span><span class="cov8" title="1">{
                        block.Statements = append(block.Statements, stmt)
                }</span>
                <span class="cov8" title="1">p.nextToken()</span>
        }
        <span class="cov8" title="1">return block</span>
}

func (p *Parser) parseFunctionLiteral() ast.Expression <span class="cov8" title="1">{
        lit := &amp;ast.FunctionLiteral{Token: p.curToken}
        if !p.expectPeek(token.LPARAN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">lit.Parameters = p.parseFunctionParameters()
        if !p.expectPeek(token.LBRACE) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">lit.Body = p.parseBlockStatement()
        return lit</span>
}

func (p *Parser) parseFunctionParameters() []*ast.Identifier <span class="cov8" title="1">{
        identifiers := []*ast.Identifier{}

        if p.peekTokenIs(token.RPARAN) </span><span class="cov8" title="1">{
                p.nextToken()
                return identifiers
        }</span>

        <span class="cov8" title="1">p.nextToken()

        ident := &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
        identifiers = append(identifiers, ident)

        for p.peekTokenIs(token.COMMA) </span><span class="cov8" title="1">{
                p.nextToken()
                p.nextToken()
                ident := &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
                identifiers = append(identifiers, ident)
        }</span>

        <span class="cov8" title="1">if !p.expectPeek(token.RPARAN) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return identifiers</span>
}

func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression <span class="cov8" title="1">{
        exp := &amp;ast.InfixExpression{
                Token:    p.curToken,
                Operator: p.curToken.Literal,
                Left:     left,
        }
        precedence := p.curPrecedence()
        p.nextToken()
        exp.Right = p.parseExpression(precedence)
        return exp
}</span>

func (p *Parser) parseCallExpression(function ast.Expression) ast.Expression <span class="cov8" title="1">{
        exp := &amp;ast.CallExpression{Token: p.curToken, Function: function}
        exp.Arguments = p.parseCallArguments()
        return exp
}</span>

func (p *Parser) parseCallArguments() []ast.Expression <span class="cov8" title="1">{
        args := []ast.Expression{}

        if p.peekTokenIs(token.RPARAN) </span><span class="cov0" title="0">{
                p.nextToken()
                return args
        }</span>

        <span class="cov8" title="1">p.nextToken()
        args = append(args, p.parseExpression(LOWEST))

        for p.peekTokenIs(token.COMMA) </span><span class="cov8" title="1">{
                p.nextToken()
                p.nextToken()
                args = append(args, p.parseExpression(LOWEST))
        }</span>

        <span class="cov8" title="1">if !p.expectPeek(token.RPARAN) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return args</span>
}

func (p *Parser) nextToken() <span class="cov8" title="1">{
        p.curToken = p.peekToken
        p.peekToken = p.l.NextToken()
}</span>

// ParseProgram parses a Monkey program.
func (p *Parser) ParseProgram() *ast.Program <span class="cov8" title="1">{
        prg := &amp;ast.Program{}
        prg.Statements = []ast.Statement{}

        for !p.curTokenIs(token.EOF) </span><span class="cov8" title="1">{
                if stmt := p.parseStatement(); stmt != nil </span><span class="cov8" title="1">{
                        prg.Statements = append(prg.Statements, stmt)
                }</span>
                <span class="cov8" title="1">p.nextToken()</span>
        }
        <span class="cov8" title="1">return prg</span>
}

func (p *Parser) parseStatement() ast.Statement <span class="cov8" title="1">{
        switch p.curToken.Type </span>{
        case token.LET:<span class="cov8" title="1">
                return p.parseLetStatement()</span>
        case token.RETURN:<span class="cov8" title="1">
                return p.parseReturnStatement()</span>
        default:<span class="cov8" title="1">
                return p.parseExpressionStatement()</span>
        }
}

func (p *Parser) parseLetStatement() *ast.LetStatement <span class="cov8" title="1">{
        stmt := &amp;ast.LetStatement{Token: p.curToken}
        if !p.expectPeek(token.IDENT) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">stmt.Name = &amp;ast.Identifier{
                Token: p.curToken,
                Value: p.curToken.Literal,
        }
        if !p.expectPeek(token.ASSIGN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">p.nextToken()
        stmt.Value = p.parseExpression(LOWEST)
        for !p.curTokenIs(token.SEMICOLON) </span><span class="cov8" title="1">{
                p.nextToken()
        }</span>
        <span class="cov8" title="1">return stmt</span>
}

func (p *Parser) parseReturnStatement() *ast.ReturnStatement <span class="cov8" title="1">{
        stmt := &amp;ast.ReturnStatement{Token: p.curToken}

        p.nextToken()

        stmt.ReturnValue = p.parseExpression(LOWEST)

        for !p.curTokenIs(token.SEMICOLON) </span><span class="cov8" title="1">{
                p.nextToken()
        }</span>
        <span class="cov8" title="1">return stmt</span>
}

func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement <span class="cov8" title="1">{
        stmt := &amp;ast.ExpressionStatement{Token: p.curToken}

        stmt.Expression = p.parseExpression(LOWEST)

        if p.peekTokenIs(token.SEMICOLON) </span><span class="cov8" title="1">{
                p.nextToken()
        }</span>

        <span class="cov8" title="1">return stmt</span>
}

func (p *Parser) expectPeek(t token.Type) bool <span class="cov8" title="1">{
        if p.peekTokenIs(t) </span><span class="cov8" title="1">{
                p.nextToken()
                return true
        }</span>
        <span class="cov0" title="0">p.peekError(t)
        return false</span>
}

func (p *Parser) curTokenIs(t token.Type) bool <span class="cov8" title="1">{
        return p.curToken.Type == t
}</span>

func (p *Parser) peekTokenIs(t token.Type) bool <span class="cov8" title="1">{
        return p.peekToken.Type == t
}</span>

func (p *Parser) registerPrefix(tokenType token.Type, fn prefixParseFn) <span class="cov8" title="1">{
        p.prefixParseFns[tokenType] = fn
}</span>

func (p *Parser) registerInfix(tokenType token.Type, fn infixParseFn) <span class="cov8" title="1">{
        p.infixParseFns[tokenType] = fn
}</span>

func (p *Parser) parseExpression(precedence int) ast.Expression <span class="cov8" title="1">{
        prefix := p.prefixParseFns[p.curToken.Type]
        if prefix == nil </span><span class="cov0" title="0">{
                p.noPrefixParseFnError(p.curToken.Type)
                return nil
        }</span>
        <span class="cov8" title="1">leftExp := prefix()

        for !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() </span><span class="cov8" title="1">{
                infix := p.infixParseFns[p.peekToken.Type]
                if infix == nil </span><span class="cov0" title="0">{
                        return leftExp
                }</span>
                <span class="cov8" title="1">p.nextToken()
                leftExp = infix(leftExp)</span>
        }
        <span class="cov8" title="1">return leftExp</span>
}

func (p *Parser) noPrefixParseFnError(t token.Type) <span class="cov0" title="0">{
        msg := fmt.Sprintf("no prefix parse function for %s found", t)
        p.errors = append(p.errors, msg)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package parser implements a parser for the Monkey programming language.
package parser

import (
        "fmt"
        "strings"
)

var traceLevel = 0

const traceIdentPlaceholder string = "\t"

func identLevel() string <span class="cov0" title="0">{
        return strings.Repeat(traceIdentPlaceholder, traceLevel-1)
}</span>

func tracePrint(fs string) <span class="cov0" title="0">{
        fmt.Printf("%s%s\n", identLevel(), fs)
}</span>

func incIdent() <span class="cov0" title="0">{ traceLevel = traceLevel + 1 }</span>
func decIdent() <span class="cov0" title="0">{ traceLevel = traceLevel - 1 }</span>

func trace(msg string) string <span class="cov0" title="0">{
        incIdent()
        tracePrint("BEGIN " + msg)
        return msg
}</span>

func untrace(msg string) <span class="cov0" title="0">{
        tracePrint("END " + msg)
        decIdent()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package repl

import (
        "bufio"
        "fmt"
        "io"
        "log"

        "github.com/w40141/monkey-language/golang/lexer"
        "github.com/w40141/monkey-language/golang/parser"
)

// prompt is the repl prompt
const (
        prompt     = "&gt;&gt; "
        monkeyFace = `
            __,__
   .--.  .-"     "-.  .--.
  / .. \/  .-. .-.  \/ .. \
 | |  '|  /   Y   \  |'  | |
 | \   \  \ 0 | 0 /  /   / |
  \ '- ,\.-"""""""-./, -' /
   ''-' /_   ^ ^   _\ '-''
       |  \._   _./  |
       \   \ '~' /   /
        '._ '-=-' _.'
           '-----'
`
)

// Start starts the REPL
func Start(in io.Reader, out io.Writer) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(in)

        for </span><span class="cov0" title="0">{
                fmt.Print(prompt)
                scanned := scanner.Scan()
                if !scanned </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">line := scanner.Text()
                l := lexer.New(line)
                p := parser.New(l)

                prg := p.ParseProgram()
                if len(p.Errors()) != 0 </span><span class="cov0" title="0">{
                        if e := printParserErrors(out, p.Errors()); e != nil </span><span class="cov0" title="0">{
                                log.Fatal(e)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if _, e := io.WriteString(out, prg.String()); e != nil </span><span class="cov0" title="0">{
                        log.Fatal(e)
                }</span>
                <span class="cov0" title="0">if _, e := io.WriteString(out, "\n"); e != nil </span><span class="cov0" title="0">{
                        log.Fatal(e)
                }</span>

                // for tok := l.NextToken(); tok.Type != token.EOF; tok = l.NextToken() {
                //         fmt.Printf("%+v\n", tok)
                // }
        }
}

func printParserErrors(out io.Writer, errors []string) error <span class="cov0" title="0">{
        io.WriteString(out, monkeyFace)
        io.WriteString(out, "Woops! We ran into some monkey business here!\n")
        io.WriteString(out, " parser errors:\n")
        for _, msg := range errors </span><span class="cov0" title="0">{
                if _, e := io.WriteString(out, "\t"+msg+"\n"); e != nil </span><span class="cov0" title="0">{
                        return e
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package token defines constants representing the lexical tokens.
package token

const (
        // ILLEGAL represent Special tokens
        ILLEGAL = "ILLEGAL"
        // EOF represents end of the file.
        EOF = "EOF"

        // IDENT represents identifiers.
        IDENT = "IDENT"
        // INT represents integers.
        INT = "INT"

        // ASSIGN represents assignment operator.
        ASSIGN = "="
        // PLUS represents addition operator.
        PLUS = "+"
        // MINUS represents subtraction operator.
        MINUS = "-"
        // TIMES represents multiplication operator.
        TIMES = "*"
        // DIVIDE represents division operator.
        DIVIDE = "/"
        // BANG represents bang operator.
        BANG = "!"

        // COMMA represents comma.
        COMMA = ","
        // SEMICOLON represents semicolon.
        SEMICOLON = ";"

        // LPARAN represents left parenthesis.
        LPARAN = "("
        // RPARAN represents right parenthesis.
        RPARAN = ")"
        // LBRACE represents left brace.
        LBRACE = "{"
        // RBRACE represents right brace.
        RBRACE = "}"
        // LT represents less than.
        LT = "&lt;"
        // GT represents greater than.
        GT = "&gt;"

        // FUNCTION represents function keyword.
        FUNCTION = "FUNCTION"
        // LET represents let keyword.
        LET = "LET"
        // TRUE represents true keyword.
        TRUE = "TRUE"
        // FALSE represents false keyword.
        FALSE = "FALSE"
        // IF represents if keyword.
        IF = "IF"
        // ELSE represents else keyword.
        ELSE = "ELSE"
        // RETURN represents return keyword.
        RETURN = "RETURN"

        // EQ represents equal operator.
        EQ = "=="
        // NQ represents not equal operator.
        NQ = "!="
)

// Type is the type of token.
type Type string

// Token is a lexical token.
type Token struct {
        Type    Type
        Literal string
}

// New returns a new instance of Token.
func New(tokenType Type, ch byte) Token <span class="cov8" title="1">{
        return Token{Type: tokenType, Literal: string(ch)}
}</span>

var keywords = map[string]Type{
        "fn":     FUNCTION,
        "let":    LET,
        "true":   TRUE,
        "false":  FALSE,
        "if":     IF,
        "else":   ELSE,
        "return": RETURN,
}

// LookupIdent returns the token type of the given identifier.
// TODO: test
func LookupIdent(ident string) Type <span class="cov8" title="1">{
        if tok, ok := keywords[ident]; ok </span><span class="cov8" title="1">{
                return tok
        }</span>
        <span class="cov8" title="1">return IDENT</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
